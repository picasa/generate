
#' Define a map between letters and glyphs
#' @description Generate a set of control points for a collection of glyphs mapped to characters
#' @param seed random seed for the character map.
#' @param n number of letters in the character map. the total length of the character map is n + 3 (addition of ".", ",", "?")
#' @param n_control number of control points for each glyph
#' @param n_tall number of tall glyphs
#' @param size_tall radius of the set of control points for tall glyphs
#' @param scale,rotation scale (0-1) and rotation (radian) of the set of control points
#' @return a dataframe with a character and layout column (set of control points).
#' @export
#'
gen_charmap <- function(
    seed, n = 26, n_control = 4, n_tall = 4, size_tall = 4,
    scale = 0.5, rotation = -pi/6) {

  # set seed for charmap
  if (!missing(seed)) set.seed(seed)

  data_map <- tibble::tibble(
    pattern = 1:(n + 3),
    character = c(letters[1:n], ".", ",", "?"),
    r = dplyr::case_when(
      rbinom((n + 3), 1, p = n_tall/(n + 3)) == 0 ~ 1,
      TRUE ~ size_tall)
  ) |>
    dplyr::mutate(layout = purrr::map(
      r, ~ layout_ellipse(n = n_control, r = ., scale_x = scale, a = rotation)))

  return(data_map)

}


#' Create a concatenated set of control points from a sequence of characters.
#' @description One glyph is created from n characters, defined by individual sets of control points.
#' @param word a sequence of characters (string)
#' @param map a character map generated by `gen_charmap()`
#' @param shift horizontal shift when concatenating individual sets of control points
#' @return a dataframe of concatenated sets of control points
#' @export
#'
layout_word <- function(word, map, shift = 1) {

  tibble::tibble(character = stringr::str_split(word, "")[[1]]) |>
    dplyr::left_join(map, by = "character") |> tidyr::drop_na() |>
    dplyr::mutate(d = seq(0, by = shift, length = dplyr::n())) |>
    dplyr::mutate(
      layout = purrr::map2(layout, d, ~ dplyr::mutate(..1, x = x + ..2))
      ) |>
    tidyr::unnest(layout)
}


#' Render a spline curve from control points
#' @param data a dataframe with x and y columns defining control points.
#' @param type control if the spline starts and ends at the terminal control points.
#' @param n number of points generated for the spline
#' @param orientation option to rotate the point set 90Â° clockwise
#' @param color,width,alpha arguments passed to `geom_bspline()`
#' @param coord coordinate system passed to `ggplot()`
#' @return a ggplot object
#' @export
#'
render_spline <- function(
  data, type = "clamped", n = 100, orientation = "h",
  color = "black", width = 0.5, alpha = 1, coord = NULL) {

  switch(
    orientation,

    h = {
      plot <- data |>
        ggplot2::ggplot(ggplot2::aes(x, y)) +
        ggforce::geom_bspline(
          lineend = "round", type = type, n = n,
          color = color, linewidth = width, alpha = alpha)
    },

    v = {
      plot <- data |>
        ggplot2::ggplot(ggplot2::aes(x = y, y = -x)) +
        ggforce::geom_bspline(
          lineend = "round", type = type, n = n,
          color = color, linewidth = width, alpha = alpha)
    },

    stop("Invalid `orientation` value")
  )

  return(plot + coord + ggplot2::theme_void())

}


#' Render a glyph set as a function of a character string and a character map.
#' @description Emulates script-like writing by juxtaposing glyphs, and adding individual variation.
#' @param text a long character sequence
#' @param map a character map generated by `gen_charmap()`
#' @param length maximum number of glyphs on a line or columns
#' @param scale scaling parameter for individual glyphs
#' @param n number of data points generated for the spline
#' @param orientation writing direction (e.g. right to left, top to bottom)
#' @param coord coordinate system for the output ggplot object
#' @param color text color
#' @param size text linewidth
#' @return a ggplot object.
#' @export

render_script <- function(
    text, map, length = 80, scale = c(2.5, 5), n = 100,
    orientation = "lrtb", coord = NULL, color = "black", size = 0.3) {

  # split input string to characters
  seq_chr <- text |> stringr::str_to_lower() |> stringr::str_split("")

  # map string characters to glyph layouts, spaces and non-match creates NULL layout
  # select one variation per character.
  string <- dplyr::tibble(glyph = seq_chr[[1]]) |>
    dplyr::mutate(position = 1:dplyr::n(), word = cumsum(glyph == " ")) |>
    dplyr::left_join(
      map |> dplyr::select(glyph = character, variation, layout), dplyr::join_by(glyph)) |>
    dplyr::slice_sample(n = 1, by = position) |>
    dplyr::filter(!purrr::map_lgl(layout, is.null))

  # layout glyphs in 2D by shifting their coordinates
  layout <- string |>
    dplyr::mutate(
      col = ((position - 1) %% length),
      row = ((position - 1) %/% length)
    ) |>
    dplyr::mutate(layout = purrr::pmap(
      list(layout, col, row),
      ~ ..1 |> dplyr::mutate(x0 = scale[1] * ..2 + x, y0 = - scale[2] * ..3 + y))) |>
    tidyr::unnest(layout)

  layout <- switch(
    orientation,
    "lrtb" = {layout |> dplyr::mutate(x = x0, y = y0)},
    "rltb" = {layout |> dplyr::mutate(x = -x0, y = y0)},
    "tbrl" = {layout |> dplyr::mutate(x = y0, y = -x0)},
    "tblr" = {layout |> dplyr::mutate(x = -y0, y = -x0)},
    stop("Invalid `orientation` value")
  )

  plot <- layout |>
    ggplot2::ggplot(ggplot2::aes(x, y, group = interaction(glyph, position))) +
    ggforce::geom_bspline(n = n, color = color, linewidth = size) +
    coord + ggplot2::theme_void()

  return(plot)

}



#' Render a line of glyphs
#' @param data a list of glyphs as ggplot objects
#' @param ncol maximum number of glyphs on a line
#' @param scale scaling parameter for individual glyphs
#' @export

render_line <- function(data, ncol = 80, scale = 0.9) {
  cowplot::plot_grid(
    plotlist = c(data$plot, list(NULL)),
    rel_widths = c(data$length, ncol - sum(data$length)),
    ncol = nrow(data) + 1, scale = scale) +
    ggplot2::theme(plot.margin = grid::unit(c(2,0,2,0), "mm"))
}


#' Render a glyph set as a function of a character string and a character map.
#' @description Emulates cursive-like writing by concatenating glyphs.
#' @param text a long character sequence
#' @param map a character map generated by `gen_charmap()`
#' @param ncol maximum number of characters per line.
#' @param shift horizontal shift when concatenating individual sets of control points
#' @param color,size color and size of the spline used to draw glyphs
#' @param n_points number of points generated for the spline
#' @param scale scaling parameter applied on individual lines fo glyphs
#' @return a ggplot object
#' @export
#'
render_cursive <- function(
  text, map, ncol = 80, shift = 1,
  color = "black", size = 0.5, n_points = 200, scale = 0.8) {
  # split text to words
  seq <- text |> stringr::str_to_lower() |> stringr::str_split(" ")

  # generate words from glyph concatenation
  # define line as groups of words of given cumulative length
  words <- tibble::tibble(word = seq[[1]]) |>
    dplyr::mutate(
      position = seq_along(word),
      length = stringr::str_length(word),
      cl = purrr::accumulate(length, ~ dplyr::if_else(.x > ncol, .y, .x + .y)),
      line = ifelse(dplyr::lag(cl, default = 0) > ncol, 1, 0) |> cumsum()
      ) |>
    dplyr::mutate(
      glyph = purrr::map(word, ~ layout_word(., map = map, shift = shift)),
      plot = purrr::map(
        glyph, ~ render_spline(
          ..1, color = color, width = size, n = n_points, type = "open")
        )
    )

  lines <- words |>
    dplyr::group_by(line) |> tidyr::nest() |>
    dplyr::mutate(plot = purrr::map(data, ~ render_line(., ncol, scale = scale)))

  cowplot::plot_grid(plotlist = lines$plot, nrow = nrow(lines), scale = scale)
}
